### 分析 - エッジケースと障害のカタログ化 - 2025-07-30
**目的**: システムで発生しうるすべてのエッジケースと潜在的な障害点を包括的に文書化する
**コンテキスト**: データフロー分析完了、システムの相互作用パターンを理解
**決定**: エッジケースを機能別に分類し、それぞれの影響と検出方法を明確化
**実行**: エッジケースマトリックスと障害モード分析の作成

## エッジケースマトリックス

### 1. Redis接続関連のエッジケース

| エッジケース | 発生条件 | 影響 | 検出方法 | 対処方法 |
|------------|---------|------|---------|---------|
| トークン期限切れ直前 | トークンTTL < 5秒 | 次回接続失敗の可能性 | トークン有効期限チェック | 事前に新トークン取得 |
| Redis接続プール枯渇 | 同時接続数 > プールサイズ | 新規接続待機/タイムアウト | 接続プールメトリクス | プールサイズ調整 |
| DNS解決失敗 | プライベートエンドポイントDNS障害 | Redis接続不可 | 名前解決エラー | DNSキャッシュ、再試行 |
| 部分的ネットワーク障害 | パケットロス発生 | 断続的な接続エラー | レイテンシ増加検出 | 再試行とタイムアウト調整 |
| Redis メモリフル | Redis使用メモリ = 上限 | 書き込み失敗 | Redis INFO memory | エビクションポリシー設定 |
| 認証スコープ不一致 | 誤ったスコープでトークン取得 | 認証失敗 | 特定のエラーメッセージ | スコープ検証ロジック |

### 2. 負荷関連のエッジケース

| エッジケース | 発生条件 | 影響 | 検出方法 | 対処方法 |
|------------|---------|------|---------|---------|
| CPU負荷100%到達 | 高負荷 + 他プロセス | システムフリーズ | CPU使用率監視 | 負荷レベル自動調整 |
| メモリ不足（OOM） | メモリ割当 > 利用可能量 | コンテナ再起動 | メモリ使用率監視 | メモリ制限設定 |
| 同時負荷制御競合 | 複数の負荷APIコール | 状態不整合 | 内部状態チェック | ロック機構実装 |
| 負荷終了タイミング競合 | 終了時刻に新規リクエスト | 予期しない負荷継続 | タイムスタンプ検証 | グレースフルシャットダウン |
| asyncioタスクリーク | タスクの不適切な終了 | メモリリーク | アクティブタスク数 | タスククリーンアップ |

### 3. Container Apps特有のエッジケース

| エッジケース | 発生条件 | 影響 | 検出方法 | 対処方法 |
|------------|---------|------|---------|---------|
| レプリカ間状態不整合 | スケールアウト時 | 異なる応答 | レプリカIDログ | 状態の外部化（Redis） |
| Ingress タイムアウト | 処理時間 > 240秒 | 504 Gateway Timeout | アクセスログ | 長時間処理の非同期化 |
| コールドスタート | 新規レプリカ起動 | 初回リクエスト遅延 | 起動時間メトリクス | ウォームアップ処理 |
| リビジョン切り替え中 | デプロイメント中 | 一時的な接続エラー | デプロイメントログ | ローリングアップデート |
| 環境変数未設定 | 設定ミス | 起動失敗 | スタートアップログ | 必須変数の検証 |

### 4. カオス注入のエッジケース

| エッジケース | 発生条件 | 影響 | 検出方法 | 対処方法 |
|------------|---------|------|---------|---------|
| NSGルール重複 | 同じルールを複数回追加 | ルール作成エラー | Azure CLIエラー | 既存ルールチェック |
| NSGルール上限 | ルール数 > 1000 | 新規ルール追加不可 | ルール数カウント | 古いルール削除 |
| ハングアップ中の再起動 | コンテナヘルスチェック失敗 | ハング状態解除 | 再起動イベント | ヘルスチェック除外オプション |
| 不正なイメージタグ形式 | 特殊文字を含むタグ | バリデーションエラー | CLIエラーメッセージ | 入力検証強化 |
| スクリプト実行権限不足 | 実行ビット未設定 | スクリプト実行失敗 | Permission denied | chmod +x 自動化 |

### 5. 監視・テレメトリのエッジケース

| エッジケース | 発生条件 | 影響 | 検出方法 | 対処方法 |
|------------|---------|------|---------|---------|
| AI接続文字列無効 | 設定ミスor期限切れ | テレメトリ送信失敗 | SDK初期化エラー | フォールバック処理 |
| テレメトリバッファオーバーフロー | 高頻度イベント | データロス | SDKログ | サンプリング調整 |
| トレースコンテキスト喪失 | 非同期処理境界 | 分断されたトレース | 孤立したスパン | コンテキスト伝播強化 |
| メトリクス名衝突 | 同名カスタムメトリクス | データ上書き | メトリクス値異常 | 命名規則確立 |

## 潜在的な障害点

### システムレベルの障害点
1. **単一障害点（SPOF）**
   - Redis（レプリケーションなし）
   - Application Insights（監視不能時）
   - Managed Identityサービス

2. **カスケード障害**
   - Redis障害 → アプリエラー → 負荷増加 → スケールアウト → コスト増加
   - NSG誤設定 → 全通信遮断 → 復旧困難
   - 高負荷 → レスポンス遅延 → タイムアウト → リトライストーム

3. **リソース枯渇**
   - コンテナメモリ上限
   - Redis接続数上限
   - NSGルール数上限
   - Application Insightsのデータ取り込み上限

### 運用上の障害点
1. **設定・構成エラー**
   - 環境変数の誤設定
   - IAMロールの権限不足
   - ネットワーク設定の不整合

2. **外部依存サービス**
   - Entra IDサービス停止
   - Azure Managed Redis障害
   - Container Apps コントロールプレーン障害

3. **人為的エラー**
   - 誤ったNSGルール適用
   - 本番環境での破壊的テスト実行
   - 不適切なスケーリング設定

## エッジケーステストシナリオ

### 1. 境界値テスト
```python
# 負荷レベル境界
test_cases = [
    {"level": "", "expected": 400},  # 空文字列
    {"level": "low", "duration_seconds": -1, "expected": 400},  # 負の期間
    {"level": "high", "duration_seconds": 86401, "expected": 400},  # 24時間超
    {"level": "medium", "duration_seconds": 0.5, "expected": 400},  # 小数
]
```

### 2. 並行性テスト
```python
# 同時リクエスト
async def test_concurrent_chaos():
    tasks = [
        post("/chaos/load", {"level": "high", "duration_seconds": 10}),
        post("/chaos/load", {"level": "low", "duration_seconds": 5}),
        post("/chaos/hang", {"duration_seconds": 3})
    ]
    results = await asyncio.gather(*tasks, return_exceptions=True)
```

### 3. タイミングテスト
```python
# 負荷終了直前/直後
async def test_load_expiry_race():
    await post("/chaos/load", {"level": "high", "duration_seconds": 1})
    await asyncio.sleep(0.95)  # 終了50ms前
    response = await get("/chaos/status")
    assert response["load"]["active"] == True
    await asyncio.sleep(0.1)  # 終了50ms後
    response = await get("/chaos/status")
    assert response["load"]["active"] == False
```

### 4. リソース制限テスト
```python
# メモリ制限到達
async def test_memory_limit():
    # Container Apps のメモリ制限に近い値を要求
    response = await post("/chaos/load", {
        "level": "high", 
        "duration_seconds": 60,
        "memory_mb": 1900  # 2GB制限に対して
    })
```

### 5. 障害注入の組み合わせ
```python
# 複合障害シナリオ
async def test_cascade_failure():
    # 1. Redisをブロック
    run_script("inject-network-failure.sh")
    
    # 2. 高負荷を注入
    await post("/chaos/load", {"level": "high", "duration_seconds": 60})
    
    # 3. 外部から負荷テスト
    run_locust("stress.py", users=1000)
    
    # 4. ヘルスチェック確認
    health = await get("/health")
    assert health["status"] == "unhealthy"
```

**出力**: エッジケースと障害点の包括的なカタログ完了
**検証**: 主要なエッジケースと潜在的な障害モードがすべて文書化された
**次**: 信頼度評価に進む